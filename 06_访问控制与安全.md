# GOST V3 入门系列（六）：访问控制与安全（把“能用”变成“敢用”）

> 本篇目标：建立最关键的安全意识与操作习惯，能把一个“跑起来的 gost”收敛成“不会随便暴露、不会被滥用、出问题能追踪”的可控服务。
>
> - 本篇会把**确定的通用安全原则**讲清楚（这些不依赖某个参数名）。
---

## 0. 结论：安全不是“加个密码”这么简单

把 gost 当成一个“网络入口”，你需要同时解决三类问题：

1. **暴露面（Exposure）**：到底谁能连到你的入站端口？（绑定地址、开放端口、防火墙）
2. **身份与准入（Identity & Admission）**：连到的人有没有权限使用？（认证、白名单、拒绝规则）
3. **可追踪性（Observability）**：出问题/被滥用时，你有没有证据？（日志、运行方式、最小留存）

> **比喻**：把 gost 想象成你家的大门  
> - **暴露面**：门开在哪面墙？临街还是内院？  
> - **身份与准入**：谁来敲门都要开门吗？还是需要验证身份？  
> - **可追踪性**：万一出事了，你知道是谁、什么时候、做了什么吗？

最常见的事故路径是：

> “为了方便测试，把监听写成 `:1080` 或 `0.0.0.0:1080` → 端口对外开放 → 没有认证/准入 → 被扫描到并滥用”

本篇就是为了让你避开这条路。

---

## 1. 威胁模型：先问 5 个问题（你才能知道该防什么）

不需要一上来就懂安全框架，只要能回答这些问题：

1. **这个入站端口会不会被公网访问到？**  
   - 如果会：必须做认证/准入，且要有防火墙与最小暴露面。
   - 就像开店：如果门开在临街，路过的人都能看到，就必须有门禁和监控。

2. **这个端口被别人用会有什么后果？**  
   - 例如：带宽被跑满、IP 被封、合规风险、内网被探测等。
   - 就像把家门钥匙给了陌生人：他可能在你家开派对、用你的水电、甚至偷东西。

3. **服务需要给谁用？**  
   - 只给自己：强烈建议只监听 `127.0.0.1`（就像只在自己房间用，不对外）。  
   - 给同网段同事：建议只绑定到内网 IP + 防火墙限制来源（就像只对小区邻居开放，但要登记）。

4. **你能否接受“被扫到就能用”？**  
   - 不能接受就必须上认证/准入。
   - 就像不能接受“任何人敲门都能进你家”。

5. **出了问题谁来排？靠什么证据排？**  
   - 没日志/没版本号/没启动命令记录，排障会非常痛苦。
   - 就像家里被偷了，但没监控、没记录，你根本不知道是谁、什么时候、做了什么。

---

## 2. 第一道防线：绑定地址（把入口“开在正确的墙上”）

这条是最确定、也最有效的原则：**能不对外开，就别对外开。**

### 2.1 三种常见绑定方式（记住安全排序）

- `127.0.0.1:PORT`：只本机可连（✅ 最安全，学习/开发首选）
- `内网IP:PORT`：只对某张网卡/某个网段可见（⚠️ 需要你理解网络边界）
- `0.0.0.0:PORT` 或 `:PORT`：所有网卡都监听（❌ 最危险，除非你明确要对外服务）

> 你可以把它想象成开店：  
> `127.0.0.1` = 只在家里招待自己；`内网IP` = 只对小区开放；`0.0.0.0` = 把店开到临街，路过都能进。

### 2.2 如何确认自己有没有“误对外暴露”（必须会的基本技能）

启动后立刻查监听，这是最直接、最可靠的验证方式：

- Windows（PowerShell）：

```powershell
netstat -ano | findstr :1080
```

- Linux/macOS：

```bash
ss -lntp | grep 1080 || netstat -an | grep 1080
```

**关键看“本地地址（Local Address）”这一列**：

- ✅ **安全**：看到 `127.0.0.1:1080` 或 `::1:1080`（只本机可访问）
- ⚠️ **需要确认**：看到 `192.168.x.x:1080` 或 `10.x.x.x:1080`（内网可见，需要确认是否预期）
- ❌ **危险**：看到 `0.0.0.0:1080` 或 `:::1080`（所有网卡都监听，很可能对外可见）

> 就像检查服务开在哪个区域  
> - `127.0.0.1` = 只在自己房间（只有本机）  
> - `192.168.x.x` = 开在小区内（内网可见）  
> - `0.0.0.0` = 开在临街（对外可见）

### 2.3 一个常见的“我以为安全，其实不安全”的坑

很多人会写：

```bash
gost -L socks5://:1080
```

这里的 `:1080` 意思是“只写端口，不写 IP”。**多数程序会把它当成“监听所有网卡”**，于是你会看到它绑定到 `0.0.0.0:1080`。

**正确的写法**（如果只想本机访问）：

```bash
gost -L socks5://127.0.0.1:1080
```

**验证方法**：启动后立刻用上面的 `netstat`/`ss` 命令检查，看到 `127.0.0.1` 才算安全。

---

## 3. 第二道防线：防火墙/安全组（就算程序监听了，也不让别人连）

> 这部分属于通用系统能力，与 gost 本身无关，因此我们可以写得确定。

### 3.1 本机学习：通常不需要开防火墙端口

如果你只监听 `127.0.0.1`，外部根本连不到，防火墙规则不是必须项。

### 3.2 服务器/内网共享：必须限制来源

原则：

- **只开放必要端口**（别为了省事开一堆）
- **只允许必要来源 IP/网段**（能白名单就白名单）

> 就像小区门禁  
> - 只开放必要端口 = 只开必要的大门（别把所有侧门都打开）  
> - 白名单限制来源 = 只有登记过的住户能进（陌生人不能进）


### 3.3 如何验证防火墙是否生效（可操作的方法）

即使配置了防火墙，也要验证它真的在起作用：

**方法 A：从外部测试连接（如果可能）**

- 从另一台机器（不在白名单里）尝试连接你的端口
- 应该被拒绝或超时
- 从白名单里的机器连接，应该能通

**方法 B：看防火墙日志**

- 如果防火墙支持日志，查看是否有“拒绝连接”的记录
- 这能证明防火墙确实在工作

> **注意**：如果只监听 `127.0.0.1`，防火墙规则通常不是必须的，因为外部根本连不到。  
> 但如果监听 `0.0.0.0` 或内网 IP，防火墙就是必须的。

---

## 4. 第三道防线：认证（Authentication）与准入（Admission）

### 4.1 先区分两个概念：认证 vs 准入

- **认证（Authentication）**：你是谁？（用户名/密码/令牌等）
- **准入（Admission）**：就算你是谁，你能不能用？（白名单、规则、策略）

> 公司门禁系统  
> - **认证**：你刷工牌，系统知道“你是张三”（验证身份）  
> - **准入**：系统检查“张三有没有权限进 5 楼”（验证权限）  
> 
> 即使你通过了认证（证明你是张三），如果准入规则说“张三不能进 5 楼”，你还是进不去。

**实际场景举例**：

- 只有认证，没有准入：任何人只要知道用户名密码就能用（就像有钥匙就能开门，不管是谁拿的钥匙）
- 只有准入，没有认证：系统不知道你是谁，只能按 IP 地址判断（就像只看地址，不看是谁在敲门）
- 两者都有：最安全（既知道你是谁，又知道你有没有权限）

### 4.2 怎么确认你当前 V3 支持哪些认证方式？

1. 运行 `gost -h` / `gost --help`
2. 找入站（通常是 `-L`）的 URL 格式说明
3. 找是否提到用户名/密码写法、或是否有相关参数

### 4.3 一个“最小可用”的思路

在本系列第二篇我们展示过“在 URL 里带用户名密码”的写法（例如 `scheme://user:pass@:port`）。  
是否在你们的 V3 Release 中对所有入站都成立，需要用下列方式验证：

**三步验证法**（必须全部通过才算成功）：

1. **启动是否报错**
   - 如果启动就报错，说明语法/参数不对，需要查 `gost -h` 或官方文档

2. **客户端不带凭据访问是否被拒绝**
   - 用 `curl` 不带用户名密码访问，应该被拒绝
   - 如果没拒绝，说明认证没生效（很危险）

3. **客户端带凭据访问是否成功**
   - 用 `curl` 带正确的用户名密码访问，应该成功
   - 如果成功，说明认证生效了


### 4.4 如何验证认证是否真的在工作

**验证步骤**（以 SOCKS5 为例，其他协议思路相同）：

1. **启动带认证的入站**（假设用户名 `user`，密码 `pass`）：

```bash
gost -L socks5://user:pass@127.0.0.1:1080
```

2. **测试 1：不带凭据访问（应该失败）**

```powershell
curl.exe --socks5 127.0.0.1:1080 http://example.com -v
```

应该看到连接被拒绝或认证失败的错误。

3. **测试 2：带错误凭据访问（应该失败）**

```powershell
curl.exe --socks5-user wrong:wrong 127.0.0.1:1080 http://example.com -v
```

应该看到认证失败的错误。

4. **测试 3：带正确凭据访问（应该成功）**

```powershell
curl.exe --socks5-user user:pass 127.0.0.1:1080 http://example.com -v
```

应该能看到正常的 HTTP 响应。

> **关键点**：只有测试 1 和测试 2 都失败，测试 3 成功，才能证明认证真的在工作。  
> 如果测试 1 或测试 2 成功了，说明认证没生效，需要检查配置。

---

## 5. 最小暴露面清单

可以把它当成“上线前必过 checklist”：

- **监听地址**：默认 `127.0.0.1`；必须对外时才用内网 IP/`0.0.0.0`
- **端口开放**：只开必要端口；服务器上配安全组/防火墙限制来源
- **认证/准入**：只要对外提供入站，就必须做（别裸奔）
- **运行方式**：后台运行要能看到日志（别把日志全丢了）
- **版本记录**：记录你用的 V3 Release 版本号（排障/回归必需）

### 5.1 如何用这个清单做“上线前自检”

**自检步骤**（启动服务前，逐项检查）：

1. **检查监听地址**
   - 启动命令里写的是 `127.0.0.1` 还是 `0.0.0.0`？
   - 如果是 `0.0.0.0`，确认是否真的需要对外服务
   - 启动后用 `netstat`/`ss` 验证实际绑定的地址

2. **检查端口**
   - 只开了必要的端口吗？
   - 如果对外，防火墙/安全组是否限制了来源？

3. **检查认证**
   - 如果对外服务，是否配置了用户名密码或认证？
   - 用“三步验证法”（见 4.4 节）确认认证真的在工作

4. **检查日志**
   - 日志输出配置了吗？
   - 日志文件路径明确吗？
   - 发起一次测试请求，日志里能看到记录吗？

5. **检查版本记录**
   - 记录了版本号吗？
   - 记录了启动命令吗？

**如果任何一项没通过，先解决再上线。**

---

## 6. 日志与可追踪性：出问题时你靠什么定位？

### 6.1 最小原则

- **能复现**：保留启动命令/配置文件
- **能定位**：保留必要日志（至少包含错误信息与连接事件）

> 就像行车记录仪  
> - 能复现 = 知道当时是怎么开的（启动命令/配置）  
> - 能定位 = 知道发生了什么（日志记录）  

### 6.2 最常见的“无法定位”原因

- 不知道自己跑的是哪个版本
- 不知道自己用了什么启动参数
- 端口对外开放了但没任何访问日志

解决办法很朴素：把这些信息写进文档模板或启动脚本里。

### 6.3 如何建立“最小可追踪性”

**方法 A：把关键信息写进启动脚本**

创建一个启动脚本（例如 `start-gost.ps1` 或 `start-gost.sh`），里面至少包含：

```powershell
# 版本信息
Write-Host "GOST Version: $(gost -V)"
Write-Host "Start Time: $(Get-Date)"

# 启动命令（完整记录）
$cmd = "gost -L socks5://user:pass@127.0.0.1:1080 -F http://upstream:8080"
Write-Host "Command: $cmd"

# 启动并记录日志
& gost -L socks5://user:pass@127.0.0.1:1080 -F http://upstream:8080 2>&1 | Tee-Object -FilePath "gost-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
```

**方法 B：记录版本号**

每次启动前，先记录版本：

```powershell
gost -V > version.txt
```

**方法 C：定期检查日志**

如果 gost 支持日志输出，确保：
- 日志文件有明确的命名（包含日期时间）
- 日志文件有足够的保留时间（至少保留最近 7 天）
- 日志包含连接事件、错误信息、认证失败等关键信息

### 6.4 如何确认“日志真的在记录”

**验证步骤**：

1. **启动 gost 并指定日志输出**（具体参数以 `gost -h` 为准）
2. **发起一次测试请求**（例如用 `curl` 访问一个网站）
3. **立刻查看日志文件**，应该能看到：
   - 连接建立记录
   - 请求目标信息
   - 成功/失败状态

如果日志里什么都没有，说明日志配置可能有问题，需要检查。

> **重要提醒**：如果端口对外开放，但没有任何访问日志，这是非常危险的。  
> 你无法知道谁在访问、访问了什么、是否有异常行为。

---

## 7. 常见安全问题与排障思路

### 7.1 问题：端口对外开放了，但不知道有没有被滥用

**排障思路**：

1. **先确认是否真的对外开放**
   - 用 `netstat`/`ss` 看监听地址
   - 如果看到 `0.0.0.0` 或 `::`，说明很可能对外可见

2. **检查是否有访问日志**
   - 如果有日志，查看是否有异常访问（来源 IP、访问频率、访问目标）
   - 如果没日志，这是严重问题，需要立刻配置日志

3. **检查是否有认证**
   - 如果没有认证，任何人都能用，需要立刻加上

4. **检查防火墙**
   - 即使有认证，也应该用防火墙限制来源 IP

**预防措施**：启动前用“最小暴露面清单”（第 5 节）自检。

### 7.2 问题：配置了认证，但不知道是否生效

**排障思路**（用 4.4 节的“三步验证法”）：

1. 不带凭据访问 → 应该失败
2. 带错误凭据访问 → 应该失败
3. 带正确凭据访问 → 应该成功

如果前两步有任何一步成功，说明认证没生效，需要检查配置。

### 7.3 问题：出问题了，但不知道当时是怎么启动的

**排障思路**：

1. **查日志文件**（如果有）
   - 日志文件里可能有启动信息

2. **查进程信息**（如果还在运行）
   - Windows：`Get-Process gost | Select-Object CommandLine`
   - Linux/macOS：`ps aux | grep gost`

3. **查配置文件**（如果用了配置文件）
   - 配置文件路径、修改时间

**预防措施**：每次启动前，把启动命令和版本号写进文档或脚本。

### 7.4 问题：不知道当前配置是否安全

**自检方法**（用第 5 节的清单）：

- 监听地址是 `127.0.0.1` 吗？
- 如果对外，有认证吗？
- 有日志吗？
- 防火墙限制来源了吗？

如果任何一项是“否”，就需要改进。

---

## 8.（可选）把“安全默认值”做成团队规范

如果要给一个“复制就不会错”的默认模板，我建议至少固定三条：

1. **默认只绑定 `127.0.0.1`**（除非明确写“对外服务”）
2. **任何对外端口必须有认证/准入 + 防火墙限制来源**
3. **启动必须可追踪**：版本号、启动命令/配置、日志路径

### 8.1 如何建立团队安全规范（实用建议）

**方法 A：创建标准启动脚本模板**

创建一个模板脚本，里面包含：
- 版本记录
- 默认绑定 `127.0.0.1`
- 日志输出配置
- 启动命令记录

只需要修改必要的参数（端口、上游等），其他安全设置已经内置。

**方法 B：建立“上线前检查清单”**

把第 5 节的清单做成团队标准流程，每次部署前必须逐项检查。

**方法 C：定期安全审计**

定期检查：
- 哪些服务在运行？
- 监听地址是什么？
- 是否有认证？
- 是否有日志？

发现问题立刻整改。

---

## 9. 本篇小结

读完本篇，应该能做到：

1. **一眼判断一个入站是否“可能对外暴露”**
   - 会用 `netstat`/`ss` 看监听地址
   - 知道 `127.0.0.1`、内网 IP、`0.0.0.0` 的区别和风险

2. **解释清楚：认证与准入的区别**
   - 认证 = 你是谁（验证身份）
   - 准入 = 你有没有权限（验证权限）

3. **知道遇到“V3 到底支不支持某种安全能力”时，如何用 `gost -h` 与官方文档得到确定答案**
   - 不靠猜，不靠第三方教程
   - 用 `gost -h` 和官方文档确认

4. **用最小暴露面 checklist 把一个可用服务收敛成可控服务**
   - 启动前自检
   - 逐项验证

5. **建立可追踪性**
   - 记录版本号
   - 记录启动命令
   - 配置日志输出
   - 验证日志真的在记录

### 9.1 最重要的三句话

1. **能不对外开，就别对外开**（默认 `127.0.0.1`）
2. **对外就必须有认证**（别裸奔）
3. **出问题要有证据**（日志、版本、启动命令）