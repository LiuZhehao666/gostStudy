# GOST V3 入门系列（四）：链路与多跳（把“流量怎么走”讲明白）

> 本篇目标：让新人能把“直连 / 单跳 / 多跳”理解成一条**可验证、可排障**的链路；并建立 Chain / Hop / Node 的位置感。  
> 本篇尽量讲“确定的概念 + 可复现的验证方法”。涉及 gost 的具体语法/参数差异时，不靠猜，**以你本机 `gost -h/--help` 和官方文档为准**。

---

## 0. 先建立一张“链路地图”：你到底在搭什么？

先别急着写命令。你要搭的本质上是一条“把流量从入口送到出口”的流水线：

- **入口（入站）**：从哪里接住连接（第 3 篇讲过）。
- **链路（Chain）**：连接从入口出发，要经过哪些中转点。
- **出口（出站）**：最后从哪里把连接发出去、去访问目标网站/服务。

用一个最直观的比喻：

- 入站像**你开了一个“收件口”**（有人能把包裹送到你这里）。
- 链路像**包裹的转运路线**（从 A 仓库 → B 中转站 → C 中转站）。
- 出站像**最后一公里派送**（从最后一个站点送到收件人）。

你可以把“多跳”理解成：**同一个包裹被接力转手了好几次**。

---

## 1. 为什么需要链路（Chain）？直连 / 单跳 / 多跳分别解决什么问题

### 1.1 直连（0 跳）：最简单、最少故障点

**直连**就是：入口接到连接后，不再经过额外代理节点，直接去访问目标。

优点：

- 延迟最低、链路最短、最好排障
- 出问题时基本只剩“本机到目标”的网络问题

缺点（也就是你为什么会想要单跳/多跳）：

- 你无法“换出口位置”（比如希望从另一台机器/另一张网卡出去）
- 你无法利用中间节点做中转（跨网段、隔离区、跳板机等）

### 1.2 单跳（1 跳）：最常见的“代理”形态

**单跳**可以理解成：你把流量先送到一个“中转站”，再由它去访问目标。

典型用途（都是“确定会遇到”的需求）：

- **固定出口**：让所有流量从某台服务器出去（例如公司出口/家里某台机器）。
- **跨网络边界**：你在 A 网络，目标在 B 网络，中间那台机器两边都能通，就用它做跳板。
- **把复杂性收敛到一处**：比如认证、限流、日志统一在那一跳处理（具体能力以你的配置为准）。

### 1.3 多跳（2+ 跳）：能解决更复杂的“到达问题”，但成本更高

**多跳**就是：中转站不止一个，A → B → C → … → 目标。

它通常是为了解决更复杂的“到达问题”：

- A 只能到 B，B 才能到 C，C 才能到目标（典型的“分段可达”）
- 你希望把“入口节点”和“出口节点”拆开（入口只负责接住，出口只负责出网，中间若干节点做过渡）

但它的代价也很确定：

- **延迟更高**：每多一跳就是一次额外网络往返 + 排队/处理时间
- **故障点更多**：任意一跳抖一下，整体就抖
- **排障更难**：必须学会“逐跳验证”，否则容易在错误方向上乱改

> 新手建议：先把单跳跑通并掌握排障方法，再上多跳。多跳不是“更高级”，只是“更绕路”。

---

## 2. 核心术语回顾：Chain / Hop / Node（用一句话说清）

先把名词说清楚，后面排障才不会乱：

- **Node（节点）**：链路上的一个“站点/机器/进程”。它可以接入、转发、再发出连接。
- **Hop（跳）**：从一个节点把连接交给下一个节点的**一次接力**。  
  你可以把 Hop 当作“第几次转手”：第 1 跳、第 2 跳……
- **Chain（链路）**：把所有 Hop 按顺序串起来的路线：Node1 → Node2 → Node3 → ……

一个很关键的“位置感”：

- **Node 是点**（站点）
- **Hop 是点与点之间的一段**（从这个站点交给下一个站点）
- **Chain 是整条路线**（所有段连起来）

---

## 3. 0/1/2 跳的最小对比（配一张小白也能看懂的图）

为了避免抽象，这里用“你在电脑上用代理访问 `example.com`”举例，只画连接方向，不绑定具体协议/命令。

### 3.1 0 跳（直连）

```
客户端/应用 →（入站）gost → 目标网站/服务
```

比喻：**你自己出门直接去店里买东西**，不经过任何代购/转运。

### 3.2 1 跳（单跳）

```
客户端/应用 →（入站）gost(入口) → gost/代理(中转站) → 目标网站/服务
```

比喻：**你把需求交给一个代购**：你只跟代购沟通，代购去店里买。

### 3.3 2 跳（多跳）

```
客户端/应用 → gost(入口) → 节点B(中转) → 节点C(出口) → 目标网站/服务
```

比喻：**包裹走“仓库→中转站→派送站”**。你只看到“我交给了收件口”，但实际背后转手两次才到目的地。

> 记住一句话：多跳不是玄学，就是“多了几次转手”。每多一次转手，就多一次可能出错的位置。

---

## 4. 最重要的方法：把链路当成“分段可测”的东西（逐跳验证）

新手最大的坑是：一上来就想把 2～3 跳一次性写完，然后“发现不通”就开始乱改。  
正确做法是：**每一跳都要能单独验证**，像搭积木一样一块块加上去。

### 4.1 先选一个“可验证目标”，别拿复杂业务当靶子

建议你先选一个尽量稳定、好观察的目标，例如：

- `example.com:80`（HTTP，方便用 `curl` 看请求是否成功）

不建议一开始就拿这些当靶子：

- 需要登录/验证码的网站（失败原因太多）
- 目标本身就不稳定的服务（你会把目标故障误判成链路故障）

### 4.2 把“多跳”拆成 N 段：每段只有一个问题

不管你有几跳，排障时永远拆成这三类段：

- **段 A（客户端 → 第 1 个入口）**：我能不能连上入口端口？入口有没有在监听？绑定地址是不是写错？
- **段 B（第 k 跳 → 第 k+1 跳）**：这一跳从当前节点能不能到下一节点？端口通不通？认证对不对？
- **段 C（最后一跳出口 → 目标）**：出口节点到目标通不通？DNS/路由/防火墙有没有问题？

这就是“逐跳验证”的核心：**一次只验证一段**。

### 4.3 Windows 上的“通不通”快速自查（不依赖 gost）

下面这些命令不依赖 gost，适合在每个节点上做“基础连通性体检”：

- 检查某端口是否能连通（推荐）：

```powershell
Test-NetConnection -ComputerName example.com -Port 80
```

- 看本机是否在监听某端口（你启动入口后必须检查）：

```powershell
netstat -ano | findstr LISTENING
```

> 提醒：`ping`（ICMP）经常被禁，ping 不通不代表 TCP 端口不通；端口通不通以 `Test-NetConnection` 为准更可靠。

### 4.4 “每一跳都能验证”的搭建顺序（从后往前最稳）

多跳最稳的搭建顺序是**从后往前**：

1. **先验证出口（最后一跳）到目标**：确保“能出得去、能访问目标”
2. 再验证倒数第二跳到出口：只要这段通，就说明“能交给出口”
3. 继续往前，一跳一跳补齐
4. 最后再让客户端接入第 1 跳入口

比喻：像搭快递路线——你先确认“派送站能送到收件人”，再确认“中转站能把包裹送到派送站”，最后才让你家门口开始收件。  
否则你在门口收了一堆包裹，却发现后面根本送不出去，很难判断是哪里断了。

---

## 5. 常见问题：问题通常出在哪一跳？怎么快速定位？

这里给一套“症状 → 优先怀疑位置”的经验法则（不依赖特定协议/参数）。

### 5.1 症状：客户端连不上入口端口（连接被拒绝/超时）

优先怀疑 **段 A（客户端 → 第 1 跳入口）**：

- 入口进程到底有没有启动成功？有没有立刻退出？
- 端口是否被占用？（第 3 篇提过 `address already in use` ）
- 绑定地址是不是写成了 `0.0.0.0` / `127.0.0.1` 导致访问范围不一致？
  - 例如入口只绑定了 `127.0.0.1`，你却从另一台机器访问，必然连不上
- 防火墙是否拦截了入站端口？（服务器部署时尤其常见）

### 5.2 症状：入口能连上，但访问目标总失败（一直转圈/无响应）

优先怀疑 **段 B 或段 C**：

- 入口到下一跳的端口通不通？（在“入口所在机器”上用 `Test-NetConnection` 测下一跳端口）
- 下一跳是否真的在监听？是否绑定在你能访问的地址上？
- 认证是否匹配？（用户名/密码/证书等，具体看你实际配置）

### 5.3 症状：偶尔能用、偶尔超时（不稳定）

多跳里常见的确定原因：

- 某一跳的网络质量抖动（延迟/丢包/拥塞）
- 某一跳资源不足（CPU/内存/连接数）

排法仍然是逐跳，只是要把验证从“测一次”变成“测一段时间”（例如连续多次 `Test-NetConnection`，观察失败比例）。

---

## 6. 新手最容易问：DNS 解析到底发生在哪？

这个问题很关键，但结论不能一概而论，因为 **DNS 发生在哪取决于“客户端怎么用代理”**，以及你用的协议/客户端实现。

这里给你一个“不会错”的理解框架：

- **如果客户端把“域名原封不动交给代理/链路”**，那么更可能由“更靠后的节点”去解析域名（甚至是出口节点）。
- **如果客户端在本地先把域名解析成 IP**，再把 IP 交给代理/链路，那 DNS 就发生在本机。

以 `curl` 举例（这是确定可验证的差异）：

- SOCKS5 本地解析（把 IP 交给代理）通常是：

```bash
curl.exe --socks5 127.0.0.1:1080 http://example.com -v
```

- SOCKS5 让代理解析（把域名交给代理）通常是：

```bash
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

> 你不需要死背哪个选项是什么含义，但要记住方法：**同一个目标域名，用“本地解析 vs 代理解析”两种方式各试一次**，结合你各节点的 DNS 能力，就能判断问题大概在哪一段。

---

## 7. 多跳的两条红线：别让学习变成“把坑挖大”

这两条不需要你精通安全，也不会错：

1. **学习阶段尽量只监听 `127.0.0.1`**，不要随手把入口开到 `0.0.0.0` / `::`（第 3 篇讲过为什么危险）。
2. **每增加一跳，都要重新做一次“逐段验证”**。多跳不是“叠加就更稳”，它只会叠加故障点。

---

## 8. 本篇小结（你应该带走什么能力）

读完本篇你应该能做到：

1. 把 Chain / Hop / Node 用一句话说清楚，并能画出 0/1/2 跳的流量图
2. 明白多跳的价值与代价：它解决“分段可达”，但增加延迟与故障点
3. 掌握最关键的排障方法：**逐跳验证、一次只验证一段**
4. 知道 DNS 不要靠猜：用“本地解析 vs 代理解析”的实验方法判断大概发生在哪

下一篇（第 5 篇）会进入“规则与策略”：当链路跑起来后，怎么让流量按你的意图走、怎么做准入与分流。