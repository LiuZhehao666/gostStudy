# GOST V3 入门系列（四）：链路与多跳（把“能跑”升级成“能串起来跑”）

> 本篇目标：能把“直连 / 单跳 / 多跳”理解成**一条可组装、可验证、可排障**的链路，并建立 **Chain / Hop / Node** 的位置感。

---

## 0. “总地图”：链路到底在哪一段？

回忆第一篇的流水线：

- **入站（Listener）**：从哪里接住连接
- **处理（Handler/规则）**：鉴权、识别目的地、套用策略
- **出站/链路（Outbound/Chain）**：把连接送到哪里、怎么送（直连/经由上游/多跳）
 
> - 入站像“收货口”  
> - 处理像“分拣规则”  
> - 链路像“发车路线”（走不走高速、走几段、在哪换乘）

---

## 1. 为什么需要链路（Chain）？直连/单跳/多跳分别解决什么问题？

### 1.1 直连（0 跳）：最短路径、最少故障点

直连的意思是：**gost（或你的应用）拿到目标地址后，直接连目标**。

- 优点：最简单、延迟最低、排障最容易
- 缺点：如果你“直连不通”，链路层面就没法帮你——你得先解决网络可达性（路由/防火墙/出口限制等）

> 从家到超市，直接走过去。路不通就是路不通，绕不开。

### 1.2 单跳（1 跳）：把“出口”换到另一台机器上

单跳的是：**我先连到一个“上游节点”，再由它去连目标**。  
这件事最核心的变化是：目标服务看到的“来访者”变成了**上游节点**（至少从网络路径/出口角度是这样）。

常见目的（只讲直觉，不假设你环境一定需要）：

- **换出口**：你希望目标侧看到的来源来自另一台机器/另一张网络
- **跨网络边界**：你这边到不了目标，但你能到一台“在另一侧”的机器，而那台机器能到目标
- **把复杂性集中到节点**：例如把某些访问控制/日志留在节点侧（具体怎么做取决于你部署方式）

> 你自己不去超市，而是先把清单交给“跑腿小哥”（上游节点），让他替你去买。

### 1.3 多跳（2+ 跳）：把路径拆成多段“换乘”

多跳的意思是：**上游节点不止一层**，连接要经过多个节点才到目标。

你可以把它理解成：把“从你到目标”的路拆成多段，每段都由一个“中转站”负责把你送到下一站。

多跳常见用法（只讲通用逻辑）：

- **把“跨边界”拆成多段**：你无法直接到达最终出口，但可以先到达一个中间站，再由它到达另一个站……
- **把不同职责分层**：例如一跳负责接入/鉴权，另一跳负责出口（是否需要取决于需求，不是必做）

### 1.4 多跳的代价：更难、更慢、更脆

这条结论是网络常识：路径越长、组件越多，整体稳定性和排障成本越高。

- **延迟**：每多一跳，通常都会增加额外 RTT/排队/加解密开销（具体大小取决于网络与协议）
- **故障点**：任何一跳出问题都会把整条链路拖死
- **排障成本**：你必须知道“坏在哪一跳”，否则只能瞎猜

> 从直达公交变成“地铁换乘 3 次”。每次换乘都可能赶不上、走错。

---

## 2. 核心术语回顾：Chain / Hop / Node（只记位置感）

> 不同项目/版本对术语细节可能不完全一致，但位置感是通用的：  
> **Chain = 整条路线；Hop = 路线中的第 N 段；Node = 承担某一段转交的节点。**

### 2.1 用一张图记住三者

```mermaid
flowchart LR
  app[客户端/应用] --> in[入站 Listener]
  in --> h1[Hop1: Node1]
  h1 --> h2[Hop2: Node2]
  h2 --> target[目标服务]
```

- **Node（节点）**：一个“接住后转交”的地方（通常是一台机器上的某个服务入口）
- **Hop（跳）**：从上一站到下一站的“这一段”（第 1 跳、第 2 跳……）
- **Chain（链路）**：把所有 Hop 串起来的“整条路线”

> 快递：  
> - Node：转运中心  
> - Hop：从 A 转运中心到 B 转运中心的运输段  
> - Chain：从你家到收件人的整条物流路线

### 2.2 0/1/2 跳的对比（非常重要）

把“跳数”跟“你要维护的节点数量”绑定起来，你才会对复杂度有真实预期：

- **0 跳（直连）**：只有你本地（或单点）要负责
- **1 跳（单跳）**：你本地 + 1 个上游节点
- **2 跳（多跳）**：你本地 + 2 个上游节点（以及它们之间的可达性）

---

## 3. “每一跳都能验证”的搭链方法（新手最稳）

这节是本篇的核心方法论：**永远不要一次性把 3 跳全配上然后祈祷它能跑**。  
正确姿势是：像搭积木一样，一次只加一块，并确保这块能独立验收。

### 3.1 准备一张“链路清单”（不写命令也能排障）

在你敲任何命令前，先写一张表（写在笔记里即可）：

| 角色 | 你在哪里 | 它对外暴露的入口 | 你用什么验证 |
|---|---|---|---|
| 本机入站 | 你的电脑 | `127.0.0.1:1080`（示例） | `netstat` + `curl.exe` |
| Hop1 节点 | 服务器/另一台机器 | `<Hop1_IP>:<Hop1_Port>` | Windows：`Test-NetConnection`；Linux：`nc`；macOS：`nc`；通用：`curl`（Windows 写 `curl.exe`） |
| Hop2 节点 | 服务器/另一台机器 | `<Hop2_IP>:<Hop2_Port>` | 同上 |

只要这张表能写清楚，后面排障就不会乱。

### 3.2 阶段 0：先做“直连基线”（不涉及 gost）

目的：确认你要访问的目标本身是正常的，且你本机网络至少能访问到它（如果你本来就直连不通，后面会更复杂）。

在 Windows 上你可以先用：

```powershell
curl.exe http://example.com -v
```

> 注意：如果你访问的是公司内网服务或特殊目标，这一步可能本来就不通，那也没关系——你至少要明确“直连不通是预期”，否则后面会把“链路问题”和“目标不可达”混在一起。

### 3.3 阶段 1：0→1（先把“本机入口”跑通）

这一步对应第二篇“最小可运行”。我们只用已经在前文出现过、且可验证的例子：

```bash
gost -L socks5://127.0.0.1:1080
```

验证分两步：

1. 看端口在监听（Windows）：

```powershell
netstat -ano | findstr :1080
```

2. 用 `curl.exe` 走代理访问测试站点：

```powershell
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

> 为什么用 `--socks5-hostname`：它会把“域名解析”交给代理侧处理。你暂时不理解也没关系，第 6 节会讲“DNS 到底在哪发生”。

### 3.4 阶段 2：1→2（把出站指向 Hop1，但只加一跳）

这一阶段你要达成的效果是：

> 应用 → 本机 socks5 入站 → **Hop1** → 目标

这里最容易写错的点，是“我以为我走了 Hop1，其实没走”。  
所以你必须同时做到两件事：

- **连得上 Hop1 的入口端口**（网络层可达）
- **让 gost 的出站确实把流量交给 Hop1**（链路层生效）

#### 3.4.1 验证“能连到 Hop1 的入口端口”

在 Windows 上最直观的是：

```powershell
Test-NetConnection <Hop1_IP> -Port <Hop1_Port>
```

如果 `TcpTestSucceeded : True`，说明 TCP 能建立连接（至少端口没被挡死）。

> 不要用 ping 当作“通不通”的唯一标准：很多网络会禁 ping，但 TCP 仍然能通。

#### 3.4.2 再让 gost “把下一站设为 Hop1”（语法以 help 为准）

这里我不直接写死某个参数名，因为不同 Release 可能差异很大。按下面方法自查：

1. 运行 `gost -h/--help`
2. 在帮助里搜索这些关键词（出现哪个用哪个）：`forward` / `node` / `chain` / `upstream` / `peer`
3. 找到“如何声明上游节点/出站”的写法后，把它填到你的“本机 socks5 服务”里

> **本机 `-L socks5://127.0.0.1:1080` 是“收货口”；你现在要补的是“发车去 Hop1 的路线”。**

**示例（仅在你的 `gost -h` 确实显示支持类似写法时使用）**：  
如果你的帮助里显示可以通过某个参数把“下一站/上游”设置为一个 SOCKS5/HTTP 代理，那么“结构”大概率长这样：

```bash
gost <声明本机入站> <声明上游为Hop1>
```

验证仍然用同一条 `curl.exe --socks5-hostname ...`。  
只要你能证明“这次请求确实经过了 Hop1”，这一步就算验收成功（下面给几个不靠猜的证据）。

#### 3.4.3 怎么证明“我真的走了 Hop1”（给你 3 种证据，任选其一）

> 多跳最容易陷入的错觉是：“我改了配置，但其实流量根本没走那条链路。”  
> 所以要学会拿证据说话。

- **证据 A：看 Hop1 的入站日志/连接记录**
  - 前提：你能在 Hop1 上看到“有连接进来”的记录
  - 你用同一条 `curl.exe` 发起请求时，Hop1 侧应该出现对应的连接/请求记录
  - 如果 Hop1 没任何记录，那“经过 Hop1”基本就不成立

- **证据 B：在 Hop1 上看实时连接（不依赖 gost，依赖系统工具）**
  - 你发起请求的瞬间，在 Hop1 上用 `netstat`/`ss` 看是否出现“来自上一跳/去往下一跳”的连接
  - 这能证明至少在网络层面，Hop1 确实在参与搬运

- **证据 C：对照“出口观测结果”是否变化（可选）**
  - 有些测试服务会回显“它看到的来源 IP/来源位置”。  
  - 如果你直连时看到的是 A，走 Hop1 后看到的是 Hop1 的出口侧特征，那就能强有力地证明链路生效。
  - 这个方法依赖外部测试服务是否可用，所以我把它当作可选证据，不作为唯一标准。

### 3.5 阶段 3：2→3（在 Hop1 后面再挂 Hop2：多跳的本质）

多跳并不神秘：它只是把“下一站”再往后延一段。

你要达成的效果是：

> 应用 → 本机入站 → Hop1 → **Hop2** → 目标

实践上，你要坚持同一个原则：**每加一跳，都能独立验证它是通的**。

最稳的验收顺序：

- 先确认 Hop1 能连到 Hop2 的入口端口（在 Hop1 上做端口连通性检查）
- 再把 Hop1 的“下一站”设为 Hop2
- 最后再用你本机的 `curl.exe` 做端到端验证

> - 你从家门口把包裹交给快递员（本机入站）  
> - 快递员先把包裹送到市级转运中心（Hop1）  
> - 市级转运中心再送到省级转运中心（Hop2）  
> - 省级转运中心再送到收件人（目标）  
> 你每加一个转运中心，都必须先确认“这两站之间的路是通的”。

---

## 4. 排障：如何判断问题出在哪一跳（把复杂问题切成小块）

这节给你一个非常实用的“切割法”：把整条链路拆成三段，你就不会乱改配置。

### 4.1 三段切割法（固定思路）

| 段 | 你要回答的问题 | 常用验证 |
|---|---|---|
| 客户端 → 本机入站 | 端口是否在监听？应用是否真的走代理？ | `netstat`、`curl.exe --socks5-hostname` |
| 本机出站 → Hop1/Hop2 | 下一站端口是否可达？鉴权是否正确？ | `Test-NetConnection`、节点侧日志 |
| 最后一跳 → 目标 | 目标是否可达？DNS/路由/防火墙是否允许？ | 直接在最后一跳机器上 `curl`/连端口测试 |

> 核心心法：  
> **不要只盯着“我本机 curl 失败了”**，那只是结果。你要把失败定位到某一段。

### 4.2 “只改一处”的排障原则

多跳链路里最致命的排障方式是：一次改 3 个地方，然后猜哪个改对了。

更稳的方式：

- **一次只动一跳**
- 动完立刻跑一组固定测试（同一条 `curl.exe`、同一组目标）
- 如果能复现问题，再继续往后动

### 4.3 最有效的证据：日志（但你要先保证“每跳都能看到”）

这条是通用建议：你需要能看到每一跳的日志/连接记录，否则你永远只能靠猜。  
具体怎么开日志、日志格式是什么，取决于你的 Release；正确做法是：

1. `gost -h/--help` 找日志相关参数/配置
2. 每一跳都把日志输出到文件
3. 用同一条测试请求触发，然后对照每跳日志是否都有对应记录

---

## 5. 常见问题 ：认证/连通性问题到底出在哪一跳？

把它当成“门禁系统”会更好理解：

- **连通性**：你能不能走到门口（TCP 能不能建连）
- **认证**：你到门口了，门让不让你进（用户名/密码/证书是否正确）

排法（从外到内）：

- 先在你本机对 Hop1 的端口做 `Test-NetConnection`（确认“能走到门口”）
- 再看 Hop1 上是否有“连接进来”的日志（确认“门口确实有人来”）
- 如果 Hop1 还要再去 Hop2，就在 Hop1 上对 Hop2 做同样的端口验证

> 不依赖 gost：  
> - **端口都连不上**：优先看防火墙/安全组/路由/监听地址绑定范围  
> - **能连上但立刻断**：优先看认证/协议不匹配/上游不可达  
> - **能连上也不报错，但访问慢/不稳定**：优先看链路质量/拥塞/节点负载

---

## 6. 常见问题 2：DNS 解析发生在哪？为什么这会影响多跳？

这块最容易绕晕，我只讲一个“绝对通用”的原则：

> **DNS 解析发生在哪，取决于“域名是谁拿着去发起连接的”。**

### 6.1 用“通讯录”比喻 DNS

- 域名（`example.com`）像“人名”
- IP 像“电话号码”
- DNS 解析像“查通讯录把人名翻成电话号码”

你可以把“DNS 在哪发生”理解成：**到底是谁在查通讯录**。

### 6.2 一个你可以马上验证的例子：`curl` 的两种 SOCKS5 用法

在 Windows 上：

- `--socks5`：通常表示“我本机先把域名解析成 IP，再把 IP 交给代理”（也就是**本机查通讯录**）
- `--socks5-hostname`：表示“我把域名原样交给代理，让代理去解析”（也就是**代理侧查通讯录**）

已经在第二篇用过：

```powershell
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

> 这个差异是工具层面的常识（不依赖 gost）。  
> 多跳时，它会放大影响：你把域名交给哪一跳，那一跳就会用“它能看到的 DNS 环境”去解析。

### 6.3 多跳里怎么“稳稳地讲清楚 DNS 在哪”？

做法很简单：你不要凭感觉，你要让“域名到底交给谁”变成显式选择。

- 如果你希望“尽量在后面的节点解析”，就确保你的请求/协议会把域名一路带过去（例如某些代理模式支持保留域名）
- 如果你希望“本机解析”，就先解析成 IP 再发（但这会影响基于域名的分流/策略）

因为不同协议/实现对“是否保留域名”支持不同，这里不写死结论；你按下面方式自证：

1. 找一个只在某个 DNS 环境能解析的域名（或用你自己的内网域名）
2. 分别用“本机解析”和“交给代理解析”的方式测试
3. 对照哪种成功、哪种失败，就能反推“解析发生在哪”

---

## 7. 安全与边界（多跳更容易“不小心暴露”）

这节只给**不会错**的原则（不依赖具体参数）：

- **原则 1：除非你明确要对外提供服务，否则入站一律先绑定 `127.0.0.1`**  
  在第三篇已经说过：写成 `:1080` 这种“只写端口不写 IP”的形式，很可能会监听到 `0.0.0.0`/`::`。

- **原则 2：不要想当然地认为“多跳=加密/更安全”**  
  具体哪一段是否加密，取决于你选的协议/配置。最稳的方法是：  
  - 看 `gost -h`/官方文档确认协议特性  
  - 必要时用抓包（如 Wireshark）验证链路上是否是明文

---

## 8. 本篇小结


1. 用“路线/换乘”的直觉解释直连、单跳、多跳
2. 说清 Chain / Hop / Node 的位置关系
3. 按“逐跳搭积木”的方法把链路搭起来：一次只加一跳，每跳都有验收手段
4. 用“三段切割法”定位问题出在哪一段，而不是靠猜
5. 用“通讯录”比喻理解 DNS，并能用 `curl` 的测试方法自证“解析发生在哪”

