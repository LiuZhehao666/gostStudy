# GOST V3 入门系列（八）：排障手册（把“出问题”变成“能解决”）

> 本篇目标：遇到问题时，不靠“猜”，而是用固定流程快速缩小范围：是入站问题、规则问题、某一跳问题、还是目标服务问题。
>
> - 本篇会把**确定的通用排障原则**讲清楚（这些不依赖某个参数名）。

---

## 0. 结论：排障不是“乱改配置”，而是“分段定位”

很多人遇到问题，第一反应是“改配置试试”。  
但正确的排障方式是：先把问题“分段”，再逐段排查。

> 就像修水管  
> - 如果水管漏水，不能到处乱修  
> - 要先找到漏水点（分段定位）  
> - 再针对性修理（逐段排查）

---

## 1. 排障总原则：先把问题“分段”

回忆第一篇的流水线：

- **入站（Listener）**：从哪里接住连接
- **处理（Handler/处理逻辑）**：鉴权、识别目的地、套用规则
- **出站/链路（Chain/Hop/Node）**：决定怎么送出去
- **目标服务**：最终要访问的服务

排障时，把整条链路拆成四段，逐段排查：

### 1.1 四段排查法（固定思路）

| 段 | 你要回答的问题 | 常用验证方法 |
|---|---|---|
| **入站** | 端口是否在监听？客户端能否连上？ | `netstat`/`ss` 看监听、`curl` 测试连接 |
| **处理** | 鉴权是否通过？规则是否匹配？ | 看日志、测试不同认证/规则 |
| **出站/链路** | 能否连上下一跳？链路是否通？ | `Test-NetConnection`/`nc` 测试端口、看节点日志 |
| **目标服务** | 目标服务是否可用？ | 直接访问目标、看目标服务日志 |

> 就像快递配送  
> - **入站** = 快递员是否到你家门口（端口是否监听）  
> - **处理** = 快递员是否验证了你的身份（鉴权/规则）  
> - **出站/链路** = 快递员能否到达下一站（链路是否通）  
> - **目标服务** = 最终目的地是否可达（目标服务是否可用）

### 1.2 为什么“分段”更有效？

**错误做法**：
- 出问题了 → 改配置 → 祈祷能好 → 不行再改 → 循环

**正确做法**：
- 出问题了 → 分段定位 → 找到问题段 → 针对性解决

**优势**：
- 不会改错地方（只改有问题的那段）
- 不会引入新问题（不改没问题的段）
- 能快速定位（逐段排查，很快就能找到）

---

## 2. 必备信息：你需要收集什么证据

排障前，先收集这些信息，否则很难定位问题。

### 2.1 基本信息（必须收集）

- **gost 版本号**：运行 `gost -V` 或 `gost --version` 获取
- **运行方式**：命令行启动还是配置文件？具体命令/配置是什么？
- **监听地址和端口**：监听在哪个地址和端口？
- **客户端复现步骤**：如何复现问题？用 `curl` 还是浏览器？具体命令是什么？

> 就像报警  
> - 报警时要说清楚：时间、地点、发生了什么  
> - 排障时也要说清楚：版本、配置、怎么复现

### 2.2 日志信息（如果有）

- **gost 日志**：是否有错误信息？是否有连接记录？
- **系统日志**：是否有系统级错误？
- **客户端日志**：客户端是否有错误信息？

具体怎么开启日志、日志格式是什么，需要查 `gost -h` 或官方文档。

### 2.3 网络信息（如果需要）

- **网络连通性**：本机能否访问目标？上游节点是否可达？
- **DNS 解析**：域名能否解析？解析到哪个 IP？
- **防火墙/安全组**：是否有防火墙规则影响？

### 2.4 一个“信息收集清单”（排障前必过）

在开始排障前，先填这个清单：

- gost 版本号：`________`
- 启动命令/配置：`________`
- 监听地址和端口：`________`
- 客户端复现步骤：`________`
- 错误信息（如果有）：`________`
- 日志（如果有）：`________`

如果这些信息都没有，排障会非常困难。

---

## 3. 常见现象 → 定位路径

### 3.1 现象：端口未监听/监听失败

**可能原因**：
1. 端口被占用
2. 启动命令/配置有误
3. 权限不足（Linux/macOS 用低端口时）
4. gost 启动后立刻退出

**排查步骤**：

1. **检查端口是否被占用**

Windows：
```powershell
netstat -ano | findstr :1080
```

Linux/macOS：
```bash
ss -lntp | grep 1080 || netstat -an | grep 1080
```

如果端口被占用，会看到其他进程在使用这个端口。

2. **检查启动命令/配置是否正确**

- 运行 `gost -h` 看命令格式是否正确
- 检查配置文件语法是否正确（如果用了配置文件）

3. **检查权限**

- Linux/macOS 用低端口（<1024）通常需要 root 权限
- 如果权限不足，改用高端口（如 1080、8080）

4. **检查 gost 是否真的在运行**

- Windows：任务管理器看是否有 `gost.exe` 进程
- Linux/macOS：`ps aux | grep gost`

如果进程不存在，说明 gost 启动后立刻退出了，需要看启动时的错误信息。

### 3.2 现象：能连上但无响应

**可能原因**：
1. 客户端没真正走代理
2. 鉴权失败（如果配置了认证）
3. 规则匹配问题（例如被 Bypass 规则拦截）
4. 出站/链路不通
5. 目标服务不可用

**排查步骤**（按顺序排查）：

1. **确认客户端是否真的走代理**

用 `curl` 测试（最可靠）：

```powershell
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

如果 `curl` 能通，说明代理工作正常，问题可能在客户端配置。

2. **检查鉴权（如果配置了认证）**

- 不带凭据访问，应该被拒绝
- 带错误凭据访问，应该被拒绝
- 带正确凭据访问，应该成功

如果前两步都失败，第三步成功，说明认证工作正常。

3. **检查规则匹配**

- 如果配置了 Bypass 规则，检查目标是否被绕过
- 如果配置了路由规则，检查规则是否匹配

4. **检查出站/链路**

- 如果是直连，直接访问目标看是否可达
- 如果走链路，检查上游节点是否可达

5. **检查目标服务**

- 不用代理直接访问目标，看是否可达
- 如果直连也不通，问题在目标服务或网络环境

### 3.3 现象：偶发断连/抖动

**可能原因**：
1. 网络质量差（延迟高、丢包）
2. 上游节点不稳定
3. 连接数限制
4. 超时设置不合理

**排查步骤**：

1. **检查网络质量**

- 用 `ping` 测试延迟和丢包（但 `ping` 不一定能完全反映 TCP 连接质量）
- 用 `curl` 测试连接建立时间

2. **检查上游节点**

- 如果走链路，检查上游节点是否稳定
- 看上游节点日志，是否有错误/超时

3. **检查连接数**

- 看系统连接数是否接近上限
- 看 gost 日志，是否有连接数相关的错误

4. **检查超时设置**

- 如果超时设置太短，正常请求也可能被误判为超时
- 如果超时设置太长，异常情况会占用资源太久

具体怎么设置超时，需要查 `gost -h` 或官方文档。

### 3.4 现象：只有某些域名不通

**可能原因**：
1. DNS 解析问题
2. 规则匹配问题（例如域名规则）
3. 目标服务问题（某些域名对应的服务不可用）

**排查步骤**：

1. **检查 DNS 解析**

- 本机能否解析这个域名？
- 解析到哪个 IP？
- 解析是否超时？

Windows：
```powershell
nslookup example.com
```

Linux/macOS：
```bash
dig example.com
```

2. **检查规则匹配**

- 如果配置了域名规则，检查这个域名是否匹配
- 如果配置了 Bypass 规则，检查这个域名是否被绕过

3. **检查目标服务**

- 不用代理直接访问这个域名，看是否可达
- 如果直连也不通，问题在目标服务或 DNS

### 3.5 现象：性能慢/延迟高

**可能原因**：
1. 网络质量差
2. 上游节点慢
3. DNS 解析慢
4. 连接数限制

**排查步骤**（参考第7篇）：

1. **先看系统资源**（CPU/内存/网络）
2. **再看连接数**
3. **再看日志/抓包**
4. **最后看上游节点**

具体方法见第7篇《性能与稳定性》。

---

## 4. 最小复现与回归验证

### 4.1 为什么要做“最小复现”？

**目的**：把复杂问题简化，找到真正的原因。

> 就像修车  
> - 如果车坏了，不能把所有零件都换一遍  
> - 要先找到坏的那个零件  
> - 再针对性修理

### 4.2 如何做“最小配置复现”？

**步骤**：

1. **从最小配置开始**

用最简单的配置启动 gost（例如：只监听本机，直连）：

```bash
gost -L socks5://127.0.0.1:1080
```

2. **测试是否正常**

用 `curl` 测试：

```powershell
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

如果正常，说明基础功能没问题。

3. **逐项加回配置**

一次只加一个配置项，每加一项就测试一次：

- 加认证 → 测试
- 加链路 → 测试
- 加规则 → 测试
- ...

4. **找到触发点**

如果加某个配置后问题出现，这个配置就是触发点。

### 4.3 如何做“回归验证”？

**目的**：确认问题真的解决了，且没有引入新问题。

**步骤**：

1. **复现原问题**

用原来的配置和步骤，确认问题确实存在。

2. **应用修复**

应用你的修复（改配置、改代码等）。

3. **验证修复**

用同样的配置和步骤，确认问题确实解决了。

4. **验证没有引入新问题**

测试其他功能，确认没有引入新问题。

> 就像修水管  
> - 修完后要开水龙头，确认不漏了（验证修复）  
> - 还要检查其他地方，确认没修坏（验证没有引入新问题）

---

## 5. 排障流程总结：一个可复用的模板

### 5.1 标准排障流程

1. **收集信息**（第2节）
   - 版本号、配置、复现步骤、日志等

2. **分段定位**（第1节）
   - 入站 → 处理 → 出站/链路 → 目标服务

3. **逐段排查**（第3节）
   - 根据现象，按定位路径排查

4. **最小复现**（第4节）
   - 如果问题复杂，做最小配置复现

5. **回归验证**（第4节）
   - 确认问题解决，且没有引入新问题

### 5.2 常见错误（避免这些坑）

**错误 1：不收集信息就开始改配置**

- 问题：不知道问题在哪，乱改配置
- 正确做法：先收集信息，再定位问题

**错误 2：一次改多个配置**

- 问题：不知道哪个配置改对了，哪个改错了
- 正确做法：一次只改一个配置，改完就测试

**错误 3：不验证就认为解决了**

- 问题：可能没真正解决，或者引入了新问题
- 正确做法：必须验证，确认问题解决且没有引入新问题

**错误 4：不记录排障过程**

- 问题：下次遇到同样问题，又要重新排查
- 正确做法：记录排障过程，形成知识库

---

## 6. 本篇小结

读完本篇，应该能做到：

1. **用“四段排查法”快速定位问题**
   - 入站 → 处理 → 出站/链路 → 目标服务

2. **收集必要的排障信息**
   - 版本号、配置、复现步骤、日志等

3. **根据现象快速找到排查路径**
   - 端口未监听 → 检查端口/启动/权限
   - 能连上但无响应 → 检查客户端/鉴权/规则/出站/目标
   - 偶发断连 → 检查网络/上游节点/连接数/超时
   - 只有某些域名不通 → 检查 DNS/规则/目标服务

4. **用“最小复现”简化复杂问题**
   - 从最小配置开始，逐项加回配置，找到触发点

5. **用“回归验证”确认问题解决**
   - 验证问题解决，且没有引入新问题

### 6.1 最重要的三句话

1. **先收集信息，再定位问题**（不要乱改配置）
2. **分段排查，逐段验证**（不要一次改多个地方）
3. **最小复现，回归验证**（确认问题解决且没有引入新问题）