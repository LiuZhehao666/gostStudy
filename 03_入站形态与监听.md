# GOST V3 入门系列（三）：入站形态与监听

> 本篇目标：彻底弄懂“入站”是什么、为什么它决定了该怎么用 gost、以及如何在 **gost V3** 里把一个入站跑起来并验证。
>
> 只需要记住一句话：**入站 = 从哪里接住连接**。  
> 后面所有配置/排障，几乎都可以从“入站是否接住”这一步开始切分。

---

## 1. 先把“入站”说清楚：它到底在做什么？

### 1.1 入站不是“协议列表”，入站是“入口位置”

很多人一上来会问：“gost 支持哪些协议？”  
更好的问题是：**我的流量现在从哪里来，我希望 gost 在哪里接住它？**

因为不同入口位置，决定了：

- 你要不要改客户端配置（浏览器/程序里填代理）
- 需不需要系统权限（例如某些入口可能需要管理员/Root）
- 排障时先看哪一层（应用层配置问题 vs 系统网络问题）

### 1.2 入站 Listener 在流水线中的位置

回到第一篇的流水线：

- **Listener**：把连接“接进来”（收货口）
- **Handler**：对连接做处理（分拣/鉴权/决定路线）
- **出站/链路**：把连接送出去（直连或多跳）

本篇聚焦 **Listener（入站）** 这一段：你如何让 gost “接到活”。

---

## 2. 你必须掌握的 3 个基础：监听地址、端口、以及绑定范围

### 2.1 监听地址（bind address）：决定谁能连到你

同一个端口 `1080`，绑定到不同地址，安全性天差地别：

- `127.0.0.1:1080`：**只有本机**能连到（本机学习/调试最推荐）
- `0.0.0.0:1080`：本机所有网卡都监听（局域网/公网都可能连到，风险高）
- `某个内网 IP:1080`：只允许连到那张网卡的机器访问（更可控）

建议：**只要不是明确要对外提供服务，就一律绑定 `127.0.0.1`。**

为了更直观，这里给一个“地址=开在哪个窗口”的对照表：

| 你绑定的地址 | 等价比喻 | 谁能访问到 | 新手推荐 |
|---|---|---|---|
| `127.0.0.1`（IPv4 回环） | “只在自己房间里开窗口” | 只有本机 | ✅ 强烈推荐 |
| `0.0.0.0`（IPv4 全部网卡） | “把窗口开在整栋楼的外墙上” | 所有能到你机器网络的人 | ❌ 除非你明确要对外服务 |
| `某个具体内网 IP` | “只在某个楼道开窗口” | 只在那张网卡所在网络可访问 | ⚠️ 需要你理解网络边界 |

### 2.2 端口（port）：决定“入口门牌号”

- 端口被占用时，gost 会启动失败（常见报错：address already in use）
- 低端口（<1024）在 Linux/macOS 通常需要更高权限

建议：从 `8080`（HTTP）或 `1080`（SOCKS5）这种高端口开始。

### 2.3 “能连上”不等于“能用”

入站层面你需要区分两件事：

- **能连上端口**：TCP 连接建立成功（说明 Listener 在监听）
- **能成功发请求并得到响应**：说明 Handler/出站也工作正常

所以验证必须分两步（第 6 节会给清单）。

### 2.4（补充）IPv6 会让你“看起来像多监听了一个地址”

如果你在 `netstat` 里看到类似 `::1` 或 `::`：

- `::1`：IPv6 的“本机回环”，作用类似 `127.0.0.1`（只本机可访问）
- `::`：IPv6 的“所有网卡”，作用类似 `0.0.0.0`（可能对外暴露）

入门阶段不需要精通 IPv6，但要会看一个结论：

> **如果监听行里出现 `0.0.0.0` 或 `::`，就要警惕：这很可能已经对外开放了。**

### 2.5 如何确认你到底“绑定到了哪里”（非常实用）

一个常见误解是：以为自己“只监听本机（`127.0.0.1`）”，但命令实际写成了 `:1080`。
这里的 `:1080` 含义是 **“只写端口、不写 IP”**，多数程序会把它当成 **“监听所有网卡”**，于是你会看到它绑定到：

- `0.0.0.0:1080`（IPv4 所有网卡）
- `[::]:1080`（IPv6 所有网卡）

对比一下更直观：

- 想只让本机访问：写成 `127.0.0.1:1080`（IPv4）或 `[::1]:1080`（IPv6 回环）
- 只写 `:1080`：通常等价于 `0.0.0.0:1080` / `[::]:1080`（可能对外暴露）

最稳的办法：启动后立刻用 `netstat`/`ss` 看监听行里的“本地地址（Local Address）”字段，**看到 `127.0.0.1`/`::1` 才算“只本机”**；如果出现 `0.0.0.0`/`::` 就要当成“全网卡监听”来处理。

---

## 3. 入站形态怎么分类？先按“你需不需要改客户端”来分

> 这是“通用方法论”，不依赖 gost 的具体支持列表。  

### 3.1 形态 A：应用显式配置的代理入口

特征：

- 你在应用里手动填代理地址（例如浏览器/IDE/命令行工具）
- 不需要改系统网络栈
- 出问题时，通常更容易定位（应用→gost→目标）

建议：

- 先跑一个本机入口（只监听 `127.0.0.1`）
- 再用 `curl` 或浏览器验证

### 3.2 形态 B：端口转发/中继类入口（适合服务端/联通测试）

特征：

- 你不一定在“应用层”配置代理
- 更像“把某个端口上的流量接住后转交到另一个地方”

它经常用于：

- 把本地某端口的连接转到远端服务
- 做联通性验证/中继
> 联通性验证：目的 = “确认能不能通/哪里不通”（偏排障、偏临时）
> 中继：目的 = “让流量通过我转发到别处”（偏中转能力、可临时也可长期）

### 3.3 形态 C：透明接入（最容易踩坑，先理解概念）

特征：

- 客户端**不需要**配置代理
- 系统层把流量“劫持/导向”到 gost 的入站

这类形态通常会带来：

- 更复杂的系统配置（路由/防火墙/策略）
- 更高权限要求
- 更难排障（因为“流量怎么进来的”不是显式配置）

---

## 4. V3 到底支持哪些入站？不要猜，用这 3 步自查

### 4.1 第一步：用 `gost --help` 找到 “-L / listen” 的用法

在你机器上运行：

```bash
gost -h
```

重点看：

- 是否存在 `-L`（通常用于声明入站监听）
- `-L` 的格式说明（一般会是 `scheme://...` 这种 URL 风格）

> 为什么让你看 `-h`：因为不同 Release 的参数细节可能变化，但 `-h` 一定与当前二进制一致。

### 4.2 第二步：用“最小例子”验证某个入站是否存在

判断一个入站类型是否真的可用，靠它能否成功启动并监听端口。

验证模板：

1. 启动（把端口换成你本机空闲端口）
2. 看它是否持续运行（没有立刻退出）
3. 用 `netstat/ss` 看端口是否在监听
4. 用 `curl` 发起一次真实请求（不是只看监听）

### 4.3 第三步：再回官方文档找“配置文件写法/进阶参数”

当你确认“这个入站确实存在且能跑”，再去官方文档看它的进阶能力（认证、TLS、日志等）。  
这样你不会陷入“看了很多配置字段但其实当前版本不支持”的坑。

---

## 5. 给新手的 2 个“必跑入站”示例（可直接复制）

> 下面这两个示例与第二篇保持一致：我只写已经在环境里反复使用、且可验证的最小形态（HTTP 代理、SOCKS5 代理）。

### 5.1 入站示例 1：SOCKS5（推荐先跑这个）

启动（更安全：只监听本机）：

```bash
gost -L socks5://127.0.0.1:1080
```

验证（用 curl 走代理访问测试站点）：

```bash
curl --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

你只要能看到响应内容/状态码，就说明入站与出站链路都通了。

### 5.2 入站示例 2：HTTP 代理（方便浏览器联动）

启动：

```bash
gost -L http://127.0.0.1:8080
```

验证：

```bash
curl -x http://127.0.0.1:8080 http://example.com -v
```

---

## 6. 客户端怎么把流量“送进入站”（最容易卡在这里）

> 入站已经启动，但没把客户端的流量指向它，就会出现“我启动了 gost，但什么也没发生”的错觉。

这里给两个最小、最通用的办法：

### 6.1 用 curl（最推荐的验证方式）

它的优点是：一步到位、输出信息非常明确、适合排障。

- SOCKS5 代理：

```bash
curl.exe --socks5-hostname 127.0.0.1:1080 http://example.com -v
```

- HTTP 代理：

```bash
curl.exe -x http://127.0.0.1:8080 http://example.com -v
```

只要 `curl` 的输出里能看到正常的 HTTP 响应（状态码、响应头、内容），就说明“客户端 → 入站 → 出站 → 目标”这条路通了。

### 6.2 用浏览器（适合“体验代理效果”，但不如 curl 适合排障）

通用思路是：在浏览器里把代理服务器设置成：

- **地址**：`127.0.0.1`
- **端口**：你启动时监听的端口（如 `1080` 或 `8080`）

注意：

- 有些浏览器使用的是“系统代理设置”，你需要去系统网络设置里改；这会影响全局流量，新手不建议一开始就这么做。
- 浏览器设置错了，很难从错误信息直接判断“到底是没走代理，还是走了但出站失败”。所以排障优先用 `curl`。

---

## 7. 入站验证清单

把入站问题分成 3 类，你就不会乱改配置：

### 7.1 启动阶段就失败（gost 立刻退出）

你应该检查：

- 端口是否被占用
- 你写的 `-L ...` 格式是否被当前 V3 接受（看 `gost -h`）
- 是否缺少权限（尤其在 Linux/macOS 用低端口时）

### 7.2 启动成功但端口不在监听（最常见是你以为启动了其实没启动）

Windows：

```powershell
netstat -ano | findstr :1080
```

Linux/macOS：

```bash
ss -lntp | grep 1080 || netstat -an | grep 1080
```

如果没有监听信息：

- 说明 gost 没有按你以为的方式启动
- 或启动后很快退出（回到 6.1）

### 7.3 端口在监听，但请求不通

这通常不是 Listener 的问题，而是后面环节：

- 客户端是否真的用了代理（例如浏览器没保存设置）
- Handler/鉴权是否拦住了（如果你配置了认证）
- 出站是否能访问目标（网络环境/解析/路由）

排法：

1. 不用代理直接 `curl http://example.com -v` 看本机是否能访问
2. 再用代理访问
3. 对比两次输出与 gost 日志

---

## 8.（可选）入站与安全：先记住这 2 条红线

即使你还没学第 6 篇，这里也先给两条“不会错”的原则：

- **红线 1：学习阶段只绑定 127.0.0.1**  
  不要用 `:1080` 或 `0.0.0.0:1080` 对外暴露，除非你非常确认自己在做什么。

- **红线 2：只要对外提供入站，就必须考虑认证/准入**  
  “没有认证的公开代理端口”基本等价于“等着被扫到后滥用”。  
  具体怎么做，按 V3 官方文档与第 6 篇落地。

---

## 9. 本篇小结

1. 用一句话解释：**入站就是 gost 的收货口**
2. 明确 3 个关键点：绑定地址、端口、验证分层
3. 会看监听行，能一眼识别“我是不是不小心对外暴露了端口”
4. 不靠猜，能用 `gost -h` + 最小示例**确认 V3 支持的入站类型**
5. 能跑通两个最常用入站：SOCKS5 与 HTTP 代理，并用 `curl` 验证